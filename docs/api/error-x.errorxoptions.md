<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@bombillazo/error-x](./error-x.md) &gt; [ErrorXOptions](./error-x.errorxoptions.md)

## ErrorXOptions type

Configuration options for creating an ErrorX instance. All properties are optional with sensible defaults.

**Signature:**

```typescript
type ErrorXOptions<TMetadata extends ErrorXMetadata = ErrorXMetadata> = {
    message?: string;
    name?: string;
    code?: string | number;
    uiMessage?: string | undefined;
    cause?: ErrorXCause | Error | unknown;
    metadata?: TMetadata | undefined;
    type?: string | undefined;
    docsUrl?: string | undefined;
    source?: string | undefined;
};
```
**References:** [ErrorXMetadata](./error-x.errorxmetadata.md)<!-- -->, [ErrorXCause](./error-x.errorxcause.md)

## Remarks

\*\*Note on design:\*\* ErrorXOptions is a `type` instead of a `class` to provide maximum flexibility. This allows you to pass plain objects without instantiation:

```typescript
// ✅ Works - plain object
new ErrorX({ message: 'Error', code: 'ERR' })

// ✅ Works - object literal
const opts = { message: 'Error' }
new ErrorX(opts)

// ✅ Works - with type-safe metadata
type MyMeta = { userId: number; action: string };
new ErrorX<MyMeta>({ metadata: { userId: 123, action: 'login' } })
```
If ErrorXOptions were a class, you would need to instantiate it:

```typescript
// ❌ Would be required with class
new ErrorX(new ErrorXOptions({ message: 'Error' }))
```
The current `type` approach provides better ergonomics while still maintaining type safety. The `isErrorXOptions()` validation method ensures only valid option objects are accepted.

